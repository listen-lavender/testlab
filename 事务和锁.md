关键是共享锁的妙用，极大提高并发度
```

CREATE TABLE Department (
    id INT PRIMARY KEY,
    parentid INT,
    name VARCHAR(100)
);

-- 事务：在A部门下增加子部门
START TRANSACTION;
-- 对父部门A加共享锁，确保其在事务期间存在且不被删除
SELECT * FROM Department WHERE id = ? LOCK IN SHARE MODE;
-- 如果查询结果为空，说明部门A不存在，回滚事务
-- 插入新的子部门
INSERT INTO Department (id, parentid, name) VALUES (?, ?, ?);
COMMIT;

-- 事务：将部门C从A迁移到B
START TRANSACTION;
-- 对源部门A和目标部门B加共享锁，确保它们存在，这里要注意加锁顺序，有死锁风险；如果有默认部门做回收桶，可以拆成两步，移出部门事务和移入部门事务，人员的部门变更调整关键也是共享锁的妙用
SELECT * FROM Department WHERE id IN (?, ?) LOCK IN SHARE MODE;
-- 对要迁移的部门C加排他锁，防止并发修改
SELECT * FROM Department WHERE id = ? FOR UPDATE;
-- 更新部门C的parentid
UPDATE Department SET parentid = ? WHERE id = ?;
COMMIT;

-- 事务：删除无子部门的A部门
START TRANSACTION;
-- 对A父部门加共享锁，确保其在事务期间存在且不被删除
SELECT * FROM Department WHERE id = (SELECT parentid FROM Department WHERE id = ?) LOCK IN SHARE MODE;
-- 对要删除的部门A加排他锁
SELECT * FROM Department WHERE id = ? FOR UPDATE;
-- 检查A部门是否有子部门，不需要加锁，因为删除更新都会锁定父部门
SELECT COUNT(*) FROM Department WHERE parentid = ?;
-- 如果有子部门(count > 0)，则回滚事务
-- 如果没有子部门，删除部门A
DELETE FROM Department WHERE id = ?;
COMMIT;
```

用户组和人员的多对多关联关系

删除用户组，需要检查人员是否存在
1. 对用户组加排他锁
2. 检查用户组和人员关联关系是否存在
3. 不存在则删除

删除人员，不需要检查用户组是否存在，如果用户组存在，需要对用户组加共享锁
1. 如果有用户组关系
2. 对用户组加共享锁
3. 移出人员（删除关联关系）
4. 解锁
5. 删除人员

加入人员，用户组存在，需要对用户组加共享锁
1. 对用户组加共享锁
2. 移入人员（增加关联关系）
3. 解锁

移出人员
1. 对用户组加共享锁
2. 移出人员（删除关联关系）
3. 解锁

以人为中心，如果有更多的业务关联，强事务需要做更多保证

数据库的行锁、表锁和全局锁是不同的。类似于代码里面的对象锁和全局锁的区别。行锁、对象锁是依附于业务实体而存在的。粒度更细。能用对象锁尽量用对象锁，能用对象上的共享锁尽量使用共享锁，如果有关联关系，就更复杂了，涉及到共享锁和排它锁的选择，涉及到加锁顺序（同一个事务或着业务request的会话内部多个锁，特别注意）问题。


