关键是共享锁的妙用，极大提高并发度
```

CREATE TABLE Department (
    id INT PRIMARY KEY,
    parentid INT,
    name VARCHAR(100)
);

-- 事务：在A部门下增加子部门
START TRANSACTION;
-- 对父部门A加共享锁，确保其在事务期间存在且不被删除
SELECT * FROM Department WHERE id = ? LOCK IN SHARE MODE;
-- 如果查询结果为空，说明部门A不存在，回滚事务
-- 插入新的子部门
INSERT INTO Department (id, parentid, name) VALUES (?, ?, ?);
COMMIT;

-- 事务：将部门C从A迁移到B
START TRANSACTION;
-- 对源部门A和目标部门B加共享锁，确保它们存在，这里要注意加锁顺序，有死锁风险；如果有默认部门做回收桶，可以拆成两步，移出部门事务和移入部门事务，人员的部门变更调整关键也是共享锁的妙用
SELECT * FROM Department WHERE id IN (?, ?) LOCK IN SHARE MODE;
-- 对要迁移的部门C加排他锁，防止并发修改
SELECT * FROM Department WHERE id = ? FOR UPDATE;
-- 更新部门C的parentid
UPDATE Department SET parentid = ? WHERE id = ?;
COMMIT;

-- 事务：删除无子部门的A部门
START TRANSACTION;
-- 对A父部门加共享锁，确保其在事务期间存在且不被删除
SELECT * FROM Department WHERE id = ? LOCK IN SHARE MODE;
-- 对要删除的部门A加排他锁
SELECT * FROM Department WHERE id = ? FOR UPDATE;
-- 检查A部门是否有子部门，不需要加锁，因为删除更新都会锁定父部门
SELECT COUNT(*) FROM Department WHERE parentid = ?;
-- 如果有子部门(count > 0)，则回滚事务
-- 如果没有子部门，删除部门A
DELETE FROM Department WHERE id = ?;
COMMIT;
```